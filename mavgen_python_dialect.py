"""
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: minimal.xml

Note: this file has been auto-generated. DO NOT EDIT
"""

import array
import hashlib
import json
import ustruct
import sys
import time
from builtins import object, range

WIRE_PROTOCOL_VERSION = "2.0"
DIALECT = "mavgen_python_dialect"

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

# Not yet supported on other dialects
native_supported = False
# Will force use of native code regardless of what client app wants
native_force =False
# Will force both native and legacy code to be used and their results compared
native_testing = False

# mavnative isn't supported for MAVLink2 yet
native_supported = False

# allow MAV_IGNORE_CRC=1 to ignore CRC, allowing some
# corrupted msgs to be seen
MAVLINK_IGNORE_CRC = True

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR = 0
MAVLINK_TYPE_UINT8_T = 1
MAVLINK_TYPE_INT8_T = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T = 8
MAVLINK_TYPE_FLOAT = 9
MAVLINK_TYPE_DOUBLE = 10


# swiped from DFReader.py
def to_string(s):
    """desperate attempt to convert a string regardless of what garbage we get"""
    try:
        return s.decode("utf-8")
    except Exception as e:
        pass
    try:
        s2 = s.encode("utf-8", "ignore")
        x = u"%s" % s2
        return s2
    except Exception:
        pass
    # so it's a nasty one. Let's grab as many characters as we can
    r = ""
    try:
        for c in s:
            r2 = r + c
            r2 = r2.encode("ascii", "ignore")
            x = u"%s" % r2
            r = r2
    except Exception:
        pass
    return r + "_XXX"


class x25crc(object):
    '''CRC-16/MCRF4XX - based on checksum.h from mavlink library'''
    def __init__(self, buf=None):
        self.crc = 0xffff
        if buf is not None:
            if isinstance(buf, str):
                self.accumulate_str(buf)
            else:
                self.accumulate(buf)

    def accumulate(self, buf):
        '''add in some more bytes'''
        accum = self.crc
        for b in buf:
            tmp = b ^ (accum & 0xff)
            tmp = (tmp ^ (tmp<<4)) & 0xFF
            accum = (accum>>8) ^ (tmp<<8) ^ (tmp<<3) ^ (tmp>>4)
        self.crc = accum

    def accumulate_str(self, buf):
        '''add in some more bytes'''
        accum = self.crc
        import array
        bytes_array = array.array('B')
        print(buf)
        try:  # if buf is bytes
            bytes_array.frombytes(buf)
        except TypeError:  # if buf is str
            bytes_array.frombytes(buf.encode())
        self.accumulate(bytes_array)

class MAVLink_header(object):
    """MAVLink message header"""

    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == "2.0" and not force_mavlink1:
            return ustruct.pack(
                "<BBBBBBBHB",
                253,
                self.mlen,
                self.incompat_flags,
                self.compat_flags,
                self.seq,
                self.srcSystem,
                self.srcComponent,
                self.msgId & 0xFFFF,
                self.msgId >> 16,
            )
        return ustruct.pack(
            "<BBBBBB",
            PROTOCOL_MARKER_V1,
            self.mlen,
            self.seq,
            self.srcSystem,
            self.srcComponent,
            self.msgId,
        )


class MAVLink_message(object):
    """base MAVLink message class"""

    def __init__(self, msgId, name):
        self._header = MAVLink_header(msgId)
        self._payload = None
        self._msgbuf = None
        self._crc = None
        self._fieldnames = []
        self._type = name
        self._signed = False
        self._link_id = None
        self._instances = None
        self._instance_field = None

    def format_attr(self, field):
        """override field getter"""
        raw_attr = getattr(self, field)
        if isinstance(raw_attr, bytes):
            raw_attr = to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = "%s {" % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += "%s : %s, " % (a, v)
        ret = ret[0:-2] + "}"
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        # if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d["mavpackettype"] = self._type
        for a in self._fieldnames:
            d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def sign_packet(self, mav):
        h = hashlib.new("sha256")
        self._msgbuf += ustruct.pack("<BQ", mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != "1.0" and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred") is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen - 1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header = MAVLink_header(
            self._header.msgId,
            incompat_flags=incompat_flags,
            compat_flags=0,
            mlen=len(self._payload),
            seq=mav.seq,
            srcSystem=mav.srcSystem,
            srcComponent=mav.srcComponent,
        )
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True:  # using CRC extra
            crc.accumulate_str(ustruct.pack("B", crc_extra))
        self._crc = crc.crc
        self._msgbuf += ustruct.pack("<H", self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def __getitem__(self, key):
        """support indexing, allowing for multi-instance sensors in one message"""
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# enums


class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}
        self.has_location = False


enums = {}

# MAV_MODE
enums["MAV_MODE"] = {}
MAV_MODE_PREFLIGHT = 0
enums["MAV_MODE"][0] = EnumEntry("MAV_MODE_PREFLIGHT", """System is not ready to fly, booting, calibrating, etc. No flag is set.""")
MAV_MODE_MANUAL_DISARMED = 64
enums["MAV_MODE"][64] = EnumEntry("MAV_MODE_MANUAL_DISARMED", """System is allowed to be active, under manual (RC) control, no stabilization""")
MAV_MODE_TEST_DISARMED = 66
enums["MAV_MODE"][66] = EnumEntry("MAV_MODE_TEST_DISARMED", """UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.""")
MAV_MODE_STABILIZE_DISARMED = 80
enums["MAV_MODE"][80] = EnumEntry("MAV_MODE_STABILIZE_DISARMED", """System is allowed to be active, under assisted RC control.""")
MAV_MODE_GUIDED_DISARMED = 88
enums["MAV_MODE"][88] = EnumEntry("MAV_MODE_GUIDED_DISARMED", """System is allowed to be active, under autonomous control, manual setpoint""")
MAV_MODE_AUTO_DISARMED = 92
enums["MAV_MODE"][92] = EnumEntry("MAV_MODE_AUTO_DISARMED", """System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)""")
MAV_MODE_MANUAL_ARMED = 192
enums["MAV_MODE"][192] = EnumEntry("MAV_MODE_MANUAL_ARMED", """System is allowed to be active, under manual (RC) control, no stabilization""")
MAV_MODE_TEST_ARMED = 194
enums["MAV_MODE"][194] = EnumEntry("MAV_MODE_TEST_ARMED", """UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.""")
MAV_MODE_STABILIZE_ARMED = 208
enums["MAV_MODE"][208] = EnumEntry("MAV_MODE_STABILIZE_ARMED", """System is allowed to be active, under assisted RC control.""")
MAV_MODE_GUIDED_ARMED = 216
enums["MAV_MODE"][216] = EnumEntry("MAV_MODE_GUIDED_ARMED", """System is allowed to be active, under autonomous control, manual setpoint""")
MAV_MODE_AUTO_ARMED = 220
enums["MAV_MODE"][220] = EnumEntry("MAV_MODE_AUTO_ARMED", """System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)""")
MAV_MODE_ENUM_END = 221
enums["MAV_MODE"][221] = EnumEntry("MAV_MODE_ENUM_END", """""")


# MAV_AUTOPILOT
enums["MAV_AUTOPILOT"] = {}
MAV_AUTOPILOT_GENERIC = 0
enums["MAV_AUTOPILOT"][0] = EnumEntry("MAV_AUTOPILOT_GENERIC", """Generic autopilot, full support for everything""")
MAV_AUTOPILOT_RESERVED = 1
enums["MAV_AUTOPILOT"][1] = EnumEntry("MAV_AUTOPILOT_RESERVED", """Reserved for future use.""")
MAV_AUTOPILOT_SLUGS = 2
enums["MAV_AUTOPILOT"][2] = EnumEntry("MAV_AUTOPILOT_SLUGS", """SLUGS autopilot, http://slugsuav.soe.ucsc.edu""")
MAV_AUTOPILOT_ARDUPILOTMEGA = 3
enums["MAV_AUTOPILOT"][3] = EnumEntry("MAV_AUTOPILOT_ARDUPILOTMEGA", """ArduPilot - Plane/Copter/Rover/Sub/Tracker, https://ardupilot.org""")
MAV_AUTOPILOT_OPENPILOT = 4
enums["MAV_AUTOPILOT"][4] = EnumEntry("MAV_AUTOPILOT_OPENPILOT", """OpenPilot, http://openpilot.org""")
MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = 5
enums["MAV_AUTOPILOT"][5] = EnumEntry("MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY", """Generic autopilot only supporting simple waypoints""")
MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6
enums["MAV_AUTOPILOT"][6] = EnumEntry("MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY", """Generic autopilot supporting waypoints and other simple navigation commands""")
MAV_AUTOPILOT_GENERIC_MISSION_FULL = 7
enums["MAV_AUTOPILOT"][7] = EnumEntry("MAV_AUTOPILOT_GENERIC_MISSION_FULL", """Generic autopilot supporting the full mission command set""")
MAV_AUTOPILOT_INVALID = 8
enums["MAV_AUTOPILOT"][8] = EnumEntry("MAV_AUTOPILOT_INVALID", """No valid autopilot, e.g. a GCS or other MAVLink component""")
MAV_AUTOPILOT_PPZ = 9
enums["MAV_AUTOPILOT"][9] = EnumEntry("MAV_AUTOPILOT_PPZ", """PPZ UAV - http://nongnu.org/paparazzi""")
MAV_AUTOPILOT_UDB = 10
enums["MAV_AUTOPILOT"][10] = EnumEntry("MAV_AUTOPILOT_UDB", """UAV Dev Board""")
MAV_AUTOPILOT_FP = 11
enums["MAV_AUTOPILOT"][11] = EnumEntry("MAV_AUTOPILOT_FP", """FlexiPilot""")
MAV_AUTOPILOT_PX4 = 12
enums["MAV_AUTOPILOT"][12] = EnumEntry("MAV_AUTOPILOT_PX4", """PX4 Autopilot - http://px4.io/""")
MAV_AUTOPILOT_SMACCMPILOT = 13
enums["MAV_AUTOPILOT"][13] = EnumEntry("MAV_AUTOPILOT_SMACCMPILOT", """SMACCMPilot - http://smaccmpilot.org""")
MAV_AUTOPILOT_AUTOQUAD = 14
enums["MAV_AUTOPILOT"][14] = EnumEntry("MAV_AUTOPILOT_AUTOQUAD", """AutoQuad -- http://autoquad.org""")
MAV_AUTOPILOT_ARMAZILA = 15
enums["MAV_AUTOPILOT"][15] = EnumEntry("MAV_AUTOPILOT_ARMAZILA", """Armazila -- http://armazila.com""")
MAV_AUTOPILOT_AEROB = 16
enums["MAV_AUTOPILOT"][16] = EnumEntry("MAV_AUTOPILOT_AEROB", """Aerob -- http://aerob.ru""")
MAV_AUTOPILOT_ASLUAV = 17
enums["MAV_AUTOPILOT"][17] = EnumEntry("MAV_AUTOPILOT_ASLUAV", """ASLUAV autopilot -- http://www.asl.ethz.ch""")
MAV_AUTOPILOT_SMARTAP = 18
enums["MAV_AUTOPILOT"][18] = EnumEntry("MAV_AUTOPILOT_SMARTAP", """SmartAP Autopilot - http://sky-drones.com""")
MAV_AUTOPILOT_AIRRAILS = 19
enums["MAV_AUTOPILOT"][19] = EnumEntry("MAV_AUTOPILOT_AIRRAILS", """AirRails - http://uaventure.com""")
MAV_AUTOPILOT_REFLEX = 20
enums["MAV_AUTOPILOT"][20] = EnumEntry("MAV_AUTOPILOT_REFLEX", """Fusion Reflex - https://fusion.engineering""")
MAV_AUTOPILOT_ENUM_END = 21
enums["MAV_AUTOPILOT"][21] = EnumEntry("MAV_AUTOPILOT_ENUM_END", """""")

# MAV_TYPE
enums["MAV_TYPE"] = {}
MAV_TYPE_GENERIC = 0
enums["MAV_TYPE"][0] = EnumEntry("MAV_TYPE_GENERIC", """Generic micro air vehicle""")
MAV_TYPE_FIXED_WING = 1
enums["MAV_TYPE"][1] = EnumEntry("MAV_TYPE_FIXED_WING", """Fixed wing aircraft.""")
MAV_TYPE_QUADROTOR = 2
enums["MAV_TYPE"][2] = EnumEntry("MAV_TYPE_QUADROTOR", """Quadrotor""")
MAV_TYPE_COAXIAL = 3
enums["MAV_TYPE"][3] = EnumEntry("MAV_TYPE_COAXIAL", """Coaxial helicopter""")
MAV_TYPE_HELICOPTER = 4
enums["MAV_TYPE"][4] = EnumEntry("MAV_TYPE_HELICOPTER", """Normal helicopter with tail rotor.""")
MAV_TYPE_ANTENNA_TRACKER = 5
enums["MAV_TYPE"][5] = EnumEntry("MAV_TYPE_ANTENNA_TRACKER", """Ground installation""")
MAV_TYPE_GCS = 6
enums["MAV_TYPE"][6] = EnumEntry("MAV_TYPE_GCS", """Operator control unit / ground control station""")
MAV_TYPE_AIRSHIP = 7
enums["MAV_TYPE"][7] = EnumEntry("MAV_TYPE_AIRSHIP", """Airship, controlled""")
MAV_TYPE_FREE_BALLOON = 8
enums["MAV_TYPE"][8] = EnumEntry("MAV_TYPE_FREE_BALLOON", """Free balloon, uncontrolled""")
MAV_TYPE_ROCKET = 9
enums["MAV_TYPE"][9] = EnumEntry("MAV_TYPE_ROCKET", """Rocket""")
MAV_TYPE_GROUND_ROVER = 10
enums["MAV_TYPE"][10] = EnumEntry("MAV_TYPE_GROUND_ROVER", """Ground rover""")
MAV_TYPE_SURFACE_BOAT = 11
enums["MAV_TYPE"][11] = EnumEntry("MAV_TYPE_SURFACE_BOAT", """Surface vessel, boat, ship""")
MAV_TYPE_SUBMARINE = 12
enums["MAV_TYPE"][12] = EnumEntry("MAV_TYPE_SUBMARINE", """Submarine""")
MAV_TYPE_HEXAROTOR = 13
enums["MAV_TYPE"][13] = EnumEntry("MAV_TYPE_HEXAROTOR", """Hexarotor""")
MAV_TYPE_OCTOROTOR = 14
enums["MAV_TYPE"][14] = EnumEntry("MAV_TYPE_OCTOROTOR", """Octorotor""")
MAV_TYPE_TRICOPTER = 15
enums["MAV_TYPE"][15] = EnumEntry("MAV_TYPE_TRICOPTER", """Tricopter""")
MAV_TYPE_FLAPPING_WING = 16
enums["MAV_TYPE"][16] = EnumEntry("MAV_TYPE_FLAPPING_WING", """Flapping wing""")
MAV_TYPE_KITE = 17
enums["MAV_TYPE"][17] = EnumEntry("MAV_TYPE_KITE", """Kite""")
MAV_TYPE_ONBOARD_CONTROLLER = 18
enums["MAV_TYPE"][18] = EnumEntry("MAV_TYPE_ONBOARD_CONTROLLER", """Onboard companion controller""")
MAV_TYPE_VTOL_TAILSITTER_DUOROTOR = 19
enums["MAV_TYPE"][19] = EnumEntry("MAV_TYPE_VTOL_TAILSITTER_DUOROTOR", """Two-rotor Tailsitter VTOL that additionally uses control surfaces in vertical operation. Note, value previously named MAV_TYPE_VTOL_DUOROTOR.""")
MAV_TYPE_VTOL_TAILSITTER_QUADROTOR = 20
enums["MAV_TYPE"][20] = EnumEntry("MAV_TYPE_VTOL_TAILSITTER_QUADROTOR", """Quad-rotor Tailsitter VTOL using a V-shaped quad config in vertical operation. Note: value previously named MAV_TYPE_VTOL_QUADROTOR.""")
MAV_TYPE_VTOL_TILTROTOR = 21
enums["MAV_TYPE"][21] = EnumEntry("MAV_TYPE_VTOL_TILTROTOR", """Tiltrotor VTOL. Fuselage and wings stay (nominally) horizontal in all flight phases. It able to tilt (some) rotors to provide thrust in cruise flight.""")
MAV_TYPE_VTOL_FIXEDROTOR = 22
enums["MAV_TYPE"][22] = EnumEntry("MAV_TYPE_VTOL_FIXEDROTOR", """VTOL with separate fixed rotors for hover and cruise flight. Fuselage and wings stay (nominally) horizontal in all flight phases.""")
MAV_TYPE_VTOL_TAILSITTER = 23
enums["MAV_TYPE"][23] = EnumEntry("MAV_TYPE_VTOL_TAILSITTER", """Tailsitter VTOL. Fuselage and wings orientation changes depending on flight phase: vertical for hover, horizontal for cruise. Use more specific VTOL MAV_TYPE_VTOL_DUOROTOR or MAV_TYPE_VTOL_QUADROTOR if appropriate.""")
MAV_TYPE_VTOL_RESERVED4 = 24
enums["MAV_TYPE"][24] = EnumEntry("MAV_TYPE_VTOL_RESERVED4", """VTOL reserved 4""")
MAV_TYPE_VTOL_RESERVED5 = 25
enums["MAV_TYPE"][25] = EnumEntry("MAV_TYPE_VTOL_RESERVED5", """VTOL reserved 5""")
MAV_TYPE_GIMBAL = 26
enums["MAV_TYPE"][26] = EnumEntry("MAV_TYPE_GIMBAL", """Gimbal""")
MAV_TYPE_ADSB = 27
enums["MAV_TYPE"][27] = EnumEntry("MAV_TYPE_ADSB", """ADSB system""")
MAV_TYPE_PARAFOIL = 28
enums["MAV_TYPE"][28] = EnumEntry("MAV_TYPE_PARAFOIL", """Steerable, nonrigid airfoil""")
MAV_TYPE_DODECAROTOR = 29
enums["MAV_TYPE"][29] = EnumEntry("MAV_TYPE_DODECAROTOR", """Dodecarotor""")
MAV_TYPE_CAMERA = 30
enums["MAV_TYPE"][30] = EnumEntry("MAV_TYPE_CAMERA", """Camera""")
MAV_TYPE_CHARGING_STATION = 31
enums["MAV_TYPE"][31] = EnumEntry("MAV_TYPE_CHARGING_STATION", """Charging station""")
MAV_TYPE_FLARM = 32
enums["MAV_TYPE"][32] = EnumEntry("MAV_TYPE_FLARM", """FLARM collision avoidance system""")
MAV_TYPE_SERVO = 33
enums["MAV_TYPE"][33] = EnumEntry("MAV_TYPE_SERVO", """Servo""")
MAV_TYPE_ODID = 34
enums["MAV_TYPE"][34] = EnumEntry("MAV_TYPE_ODID", """Open Drone ID. See https://mavlink.io/en/services/opendroneid.html.""")
MAV_TYPE_DECAROTOR = 35
enums["MAV_TYPE"][35] = EnumEntry("MAV_TYPE_DECAROTOR", """Decarotor""")
MAV_TYPE_BATTERY = 36
enums["MAV_TYPE"][36] = EnumEntry("MAV_TYPE_BATTERY", """Battery""")
MAV_TYPE_PARACHUTE = 37
enums["MAV_TYPE"][37] = EnumEntry("MAV_TYPE_PARACHUTE", """Parachute""")
MAV_TYPE_LOG = 38
enums["MAV_TYPE"][38] = EnumEntry("MAV_TYPE_LOG", """Log""")
MAV_TYPE_OSD = 39
enums["MAV_TYPE"][39] = EnumEntry("MAV_TYPE_OSD", """OSD""")
MAV_TYPE_IMU = 40
enums["MAV_TYPE"][40] = EnumEntry("MAV_TYPE_IMU", """IMU""")
MAV_TYPE_GPS = 41
enums["MAV_TYPE"][41] = EnumEntry("MAV_TYPE_GPS", """GPS""")
MAV_TYPE_WINCH = 42
enums["MAV_TYPE"][42] = EnumEntry("MAV_TYPE_WINCH", """Winch""")
MAV_TYPE_ENUM_END = 43
enums["MAV_TYPE"][43] = EnumEntry("MAV_TYPE_ENUM_END", """""")

# MAV_MODE_FLAG
enums["MAV_MODE_FLAG"] = {}
MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1
enums["MAV_MODE_FLAG"][1] = EnumEntry("MAV_MODE_FLAG_CUSTOM_MODE_ENABLED", """0b00000001 Reserved for future use.""")
MAV_MODE_FLAG_TEST_ENABLED = 2
enums["MAV_MODE_FLAG"][2] = EnumEntry("MAV_MODE_FLAG_TEST_ENABLED", """0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations.""")
MAV_MODE_FLAG_AUTO_ENABLED = 4
enums["MAV_MODE_FLAG"][4] = EnumEntry("MAV_MODE_FLAG_AUTO_ENABLED", """0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation.""")
MAV_MODE_FLAG_GUIDED_ENABLED = 8
enums["MAV_MODE_FLAG"][8] = EnumEntry("MAV_MODE_FLAG_GUIDED_ENABLED", """0b00001000 guided mode enabled, system flies waypoints / mission items.""")
MAV_MODE_FLAG_STABILIZE_ENABLED = 16
enums["MAV_MODE_FLAG"][16] = EnumEntry("MAV_MODE_FLAG_STABILIZE_ENABLED", """0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around.""")
MAV_MODE_FLAG_HIL_ENABLED = 32
enums["MAV_MODE_FLAG"][32] = EnumEntry("MAV_MODE_FLAG_HIL_ENABLED", """0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational.""")
MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64
enums["MAV_MODE_FLAG"][64] = EnumEntry("MAV_MODE_FLAG_MANUAL_INPUT_ENABLED", """0b01000000 remote control input is enabled.""")
MAV_MODE_FLAG_SAFETY_ARMED = 128
enums["MAV_MODE_FLAG"][128] = EnumEntry("MAV_MODE_FLAG_SAFETY_ARMED", """0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state.""")
MAV_MODE_FLAG_ENUM_END = 129
enums["MAV_MODE_FLAG"][129] = EnumEntry("MAV_MODE_FLAG_ENUM_END", """""")

# MAV_CMD
enums["MAV_CMD"] = {}
MAV_CMD_NAV_WAYPOINT = 16
enums["MAV_CMD"][16] = EnumEntry("MAV_CMD_NAV_WAYPOINT", """Navigate to waypoint.""")
enums["MAV_CMD"][16].has_location = True
enums["MAV_CMD"][16].param[1] = """Hold time. (ignored by fixed wing, time to stay at waypoint for rotary wing)"""
enums["MAV_CMD"][16].param[2] = """Acceptance radius (if the sphere with this radius is hit, the waypoint counts as reached)"""
enums["MAV_CMD"][16].param[3] = """0 to pass through the WP, if > 0 radius to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control."""
enums["MAV_CMD"][16].param[4] = """Desired yaw angle at waypoint (rotary wing). NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.)."""
enums["MAV_CMD"][16].param[5] = """Latitude"""
enums["MAV_CMD"][16].param[6] = """Longitude"""
enums["MAV_CMD"][16].param[7] = """Altitude"""
MAV_CMD_NAV_RETURN_TO_LAUNCH = 20
enums["MAV_CMD"][20] = EnumEntry("MAV_CMD_NAV_RETURN_TO_LAUNCH", """Return to launch location""")
enums["MAV_CMD"][20].param[1] = """Empty"""
enums["MAV_CMD"][20].param[2] = """Empty"""
enums["MAV_CMD"][20].param[3] = """Empty"""
enums["MAV_CMD"][20].param[4] = """Empty"""
enums["MAV_CMD"][20].param[5] = """Empty"""
enums["MAV_CMD"][20].param[6] = """Empty"""
enums["MAV_CMD"][20].param[7] = """Empty"""
MAV_CMD_NAV_LAND = 21
enums["MAV_CMD"][21] = EnumEntry("MAV_CMD_NAV_LAND", """Land at location.""")
enums["MAV_CMD"][21].has_location = True
enums["MAV_CMD"][21].param[1] = """Minimum target altitude if landing is aborted (0 = undefined/use system default)."""
enums["MAV_CMD"][21].param[2] = """Precision land mode."""
enums["MAV_CMD"][21].param[3] = """Empty."""
enums["MAV_CMD"][21].param[4] = """Desired yaw angle. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.)."""
enums["MAV_CMD"][21].param[5] = """Latitude."""
enums["MAV_CMD"][21].param[6] = """Longitude."""
enums["MAV_CMD"][21].param[7] = """Landing altitude (ground level in current frame)."""
MAV_CMD_NAV_TAKEOFF = 22
enums["MAV_CMD"][22] = EnumEntry("MAV_CMD_NAV_TAKEOFF", """Takeoff from ground / hand. Vehicles that support multiple takeoff modes (e.g. VTOL quadplane) should take off using the currently configured mode.""")
enums["MAV_CMD"][22].has_location = True
enums["MAV_CMD"][22].param[1] = """Minimum pitch (if airspeed sensor present), desired pitch without sensor"""
enums["MAV_CMD"][22].param[2] = """Empty"""
enums["MAV_CMD"][22].param[3] = """Empty"""
enums["MAV_CMD"][22].param[4] = """Yaw angle (if magnetometer present), ignored without magnetometer. NaN to use the current system yaw heading mode (e.g. yaw towards next waypoint, yaw to home, etc.)."""
enums["MAV_CMD"][22].param[5] = """Latitude"""
enums["MAV_CMD"][22].param[6] = """Longitude"""
enums["MAV_CMD"][22].param[7] = """Altitude"""
MAV_CMD_DO_SET_MODE = 176
enums["MAV_CMD"][176] = EnumEntry("MAV_CMD_DO_SET_MODE", """Set system mode.""")
enums["MAV_CMD"][176].param[1] = """Mode"""
enums["MAV_CMD"][176].param[2] = """Custom mode - this is system specific, please refer to the individual autopilot specifications for details."""
enums["MAV_CMD"][176].param[3] = """Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details."""
enums["MAV_CMD"][176].param[4] = """Empty"""
enums["MAV_CMD"][176].param[5] = """Empty"""
enums["MAV_CMD"][176].param[6] = """Empty"""
enums["MAV_CMD"][176].param[7] = """Empty"""
MAV_CMD_DO_CHANGE_SPEED = 178
enums["MAV_CMD"][178] = EnumEntry("MAV_CMD_DO_CHANGE_SPEED", """Change speed and/or throttle set points.""")
enums["MAV_CMD"][178].param[1] = """Speed type (0=Airspeed, 1=Ground Speed, 2=Climb Speed, 3=Descent Speed)"""
enums["MAV_CMD"][178].param[2] = """Speed (-1 indicates no change)"""
enums["MAV_CMD"][178].param[3] = """Throttle (-1 indicates no change)"""
enums["MAV_CMD"][178].param[4] = """0: absolute, 1: relative"""
enums["MAV_CMD"][178].param[5] = """Empty"""
enums["MAV_CMD"][178].param[6] = """Empty"""
enums["MAV_CMD"][178].param[7] = """Empty"""
MAV_CMD_DO_SET_HOME = 179
enums["MAV_CMD"][179] = EnumEntry("MAV_CMD_DO_SET_HOME", """Changes the home location either to the current location or a specified location.""")
enums["MAV_CMD"][179].has_location = True
enums["MAV_CMD"][179].param[1] = """Use current (1=use current location, 0=use specified location)"""
enums["MAV_CMD"][179].param[2] = """Empty"""
enums["MAV_CMD"][179].param[3] = """Empty"""
enums["MAV_CMD"][179].param[4] = """Empty"""
enums["MAV_CMD"][179].param[5] = """Latitude"""
enums["MAV_CMD"][179].param[6] = """Longitude"""
enums["MAV_CMD"][179].param[7] = """Altitude"""
MAV_CMD_DO_SET_PARAMETER = 180
enums["MAV_CMD"][180] = EnumEntry("MAV_CMD_DO_SET_PARAMETER", """Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter.""")
enums["MAV_CMD"][180].param[1] = """Parameter number"""
enums["MAV_CMD"][180].param[2] = """Parameter value"""
enums["MAV_CMD"][180].param[3] = """Empty"""
enums["MAV_CMD"][180].param[4] = """Empty"""
enums["MAV_CMD"][180].param[5] = """Empty"""
enums["MAV_CMD"][180].param[6] = """Empty"""
enums["MAV_CMD"][180].param[7] = """Empty"""
MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246
enums["MAV_CMD"][246] = EnumEntry("MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN", """Request the reboot or shutdown of system components.""")
enums["MAV_CMD"][246].param[1] = """0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded."""
enums["MAV_CMD"][246].param[2] = """0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded."""
enums["MAV_CMD"][246].param[3] = """WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded"""
enums["MAV_CMD"][246].param[4] = """WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded"""
enums["MAV_CMD"][246].param[5] = """Reserved (set to 0)"""
enums["MAV_CMD"][246].param[6] = """Reserved (set to 0)"""
enums["MAV_CMD"][246].param[7] = """WIP: ID (e.g. camera ID -1 for all IDs)"""
MAV_CMD_REQUEST_MESSAGE = 512
enums["MAV_CMD"][512] = EnumEntry("MAV_CMD_REQUEST_MESSAGE", """Request the target system(s) emit a single instance of a specified message (i.e. a "one-shot" version of MAV_CMD_SET_MESSAGE_INTERVAL).""")
enums["MAV_CMD"][512].param[1] = """The MAVLink message ID of the requested message."""
enums["MAV_CMD"][512].param[2] = """Use for index ID, if required. Otherwise, the use of this parameter (if any) must be defined in the requested message. By default assumed not used (0)."""
enums["MAV_CMD"][512].param[3] = """The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0)."""
enums["MAV_CMD"][512].param[4] = """The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0)."""
enums["MAV_CMD"][512].param[5] = """The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0)."""
enums["MAV_CMD"][512].param[6] = """The use of this parameter (if any), must be defined in the requested message. By default assumed not used (0)."""
enums["MAV_CMD"][512].param[7] = """Target address for requested message (if message has target address fields). 0: Flight-stack default, 1: address of requestor, 2: broadcast."""
MAV_CMD_REQUEST_PROTOCOL_VERSION = 519
enums["MAV_CMD"][519] = EnumEntry("MAV_CMD_REQUEST_PROTOCOL_VERSION", """Request MAVLink protocol version compatibility. All receivers should ACK the command and then emit their capabilities in an PROTOCOL_VERSION message""")
enums["MAV_CMD"][519].param[1] = """1: Request supported protocol versions by all nodes on the network"""
enums["MAV_CMD"][519].param[2] = """Reserved (all remaining params)"""
enums["MAV_CMD"][519].param[3] = """Reserved (default:0)"""
enums["MAV_CMD"][519].param[4] = """Reserved (default:0)"""
enums["MAV_CMD"][519].param[5] = """Reserved (default:0)"""
enums["MAV_CMD"][519].param[6] = """Reserved (default:0)"""
enums["MAV_CMD"][519].param[7] = """Reserved (default:0)"""
enums["MAV_CMD"][42601] = EnumEntry("MAV_CMD_ENUM_END", """""")


# MAV_MODE_FLAG_DECODE_POSITION
enums["MAV_MODE_FLAG_DECODE_POSITION"] = {}
MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE = 1
enums["MAV_MODE_FLAG_DECODE_POSITION"][1] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE", """Eighth bit: 00000001""")
MAV_MODE_FLAG_DECODE_POSITION_TEST = 2
enums["MAV_MODE_FLAG_DECODE_POSITION"][2] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_TEST", """Seventh bit: 00000010""")
MAV_MODE_FLAG_DECODE_POSITION_AUTO = 4
enums["MAV_MODE_FLAG_DECODE_POSITION"][4] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_AUTO", """Sixth bit:   00000100""")
MAV_MODE_FLAG_DECODE_POSITION_GUIDED = 8
enums["MAV_MODE_FLAG_DECODE_POSITION"][8] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_GUIDED", """Fifth bit:  00001000""")
MAV_MODE_FLAG_DECODE_POSITION_STABILIZE = 16
enums["MAV_MODE_FLAG_DECODE_POSITION"][16] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_STABILIZE", """Fourth bit: 00010000""")
MAV_MODE_FLAG_DECODE_POSITION_HIL = 32
enums["MAV_MODE_FLAG_DECODE_POSITION"][32] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_HIL", """Third bit:  00100000""")
MAV_MODE_FLAG_DECODE_POSITION_MANUAL = 64
enums["MAV_MODE_FLAG_DECODE_POSITION"][64] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_MANUAL", """Second bit: 01000000""")
MAV_MODE_FLAG_DECODE_POSITION_SAFETY = 128
enums["MAV_MODE_FLAG_DECODE_POSITION"][128] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_SAFETY", """First bit:  10000000""")
MAV_MODE_FLAG_DECODE_POSITION_ENUM_END = 129
enums["MAV_MODE_FLAG_DECODE_POSITION"][129] = EnumEntry("MAV_MODE_FLAG_DECODE_POSITION_ENUM_END", """""")

# MAV_STATE
enums["MAV_STATE"] = {}
MAV_STATE_UNINIT = 0
enums["MAV_STATE"][0] = EnumEntry("MAV_STATE_UNINIT", """Uninitialized system, state is unknown.""")
MAV_STATE_BOOT = 1
enums["MAV_STATE"][1] = EnumEntry("MAV_STATE_BOOT", """System is booting up.""")
MAV_STATE_CALIBRATING = 2
enums["MAV_STATE"][2] = EnumEntry("MAV_STATE_CALIBRATING", """System is calibrating and not flight-ready.""")
MAV_STATE_STANDBY = 3
enums["MAV_STATE"][3] = EnumEntry("MAV_STATE_STANDBY", """System is grounded and on standby. It can be launched any time.""")
MAV_STATE_ACTIVE = 4
enums["MAV_STATE"][4] = EnumEntry("MAV_STATE_ACTIVE", """System is active and might be already airborne. Motors are engaged.""")
MAV_STATE_CRITICAL = 5
enums["MAV_STATE"][5] = EnumEntry("MAV_STATE_CRITICAL", """System is in a non-normal flight mode. It can however still navigate.""")
MAV_STATE_EMERGENCY = 6
enums["MAV_STATE"][6] = EnumEntry("MAV_STATE_EMERGENCY", """System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in mayday and going down.""")
MAV_STATE_POWEROFF = 7
enums["MAV_STATE"][7] = EnumEntry("MAV_STATE_POWEROFF", """System just initialized its power-down sequence, will shut down now.""")
MAV_STATE_FLIGHT_TERMINATION = 8
enums["MAV_STATE"][8] = EnumEntry("MAV_STATE_FLIGHT_TERMINATION", """System is terminating itself.""")
MAV_STATE_ENUM_END = 9
enums["MAV_STATE"][9] = EnumEntry("MAV_STATE_ENUM_END", """""")

# MAV_COMPONENT
enums["MAV_COMPONENT"] = {}
MAV_COMP_ID_ALL = 0
enums["MAV_COMPONENT"][0] = EnumEntry("MAV_COMP_ID_ALL", """Target id (target_component) used to broadcast messages to all components of the receiving system. Components should attempt to process messages with this component ID and forward to components on any other interfaces. Note: This is not a valid *source* component id for a message.""")
MAV_COMP_ID_AUTOPILOT1 = 1
enums["MAV_COMPONENT"][1] = EnumEntry("MAV_COMP_ID_AUTOPILOT1", """System flight controller component ("autopilot"). Only one autopilot is expected in a particular system.""")
MAV_COMP_ID_USER1 = 25
enums["MAV_COMPONENT"][25] = EnumEntry("MAV_COMP_ID_USER1", """Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.""")
MAV_COMP_ID_USER2 = 26
enums["MAV_COMPONENT"][26] = EnumEntry("MAV_COMP_ID_USER2", """Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.""")
MAV_COMP_ID_USER3 = 27
enums["MAV_COMPONENT"][27] = EnumEntry("MAV_COMP_ID_USER3", """Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.""")
MAV_COMP_ID_USER4 = 28
enums["MAV_COMPONENT"][28] = EnumEntry("MAV_COMP_ID_USER4", """Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.""")
MAV_COMP_ID_USER5 = 29
enums["MAV_COMPONENT"][29] = EnumEntry("MAV_COMP_ID_USER5", """Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.""")
MAV_COMP_ID_TELEMETRY_RADIO = 68
enums["MAV_COMPONENT"][68] = EnumEntry("MAV_COMP_ID_TELEMETRY_RADIO", """Telemetry radio (e.g. SiK radio, or other component that emits RADIO_STATUS messages).""")
MAV_COMP_ID_CAMERA = 100
enums["MAV_COMPONENT"][100] = EnumEntry("MAV_COMP_ID_CAMERA", """Camera #1.""")
MAV_COMP_ID_CAMERA2 = 101
enums["MAV_COMPONENT"][101] = EnumEntry("MAV_COMP_ID_CAMERA2", """Camera #2.""")
MAV_COMP_ID_CAMERA3 = 102
enums["MAV_COMPONENT"][102] = EnumEntry("MAV_COMP_ID_CAMERA3", """Camera #3.""")
MAV_COMP_ID_CAMERA4 = 103
enums["MAV_COMPONENT"][103] = EnumEntry("MAV_COMP_ID_CAMERA4", """Camera #4.""")
MAV_COMP_ID_CAMERA5 = 104
enums["MAV_COMPONENT"][104] = EnumEntry("MAV_COMP_ID_CAMERA5", """Camera #5.""")
MAV_COMP_ID_CAMERA6 = 105
enums["MAV_COMPONENT"][105] = EnumEntry("MAV_COMP_ID_CAMERA6", """Camera #6.""")
MAV_COMP_ID_SERVO1 = 140
enums["MAV_COMPONENT"][140] = EnumEntry("MAV_COMP_ID_SERVO1", """Servo #1.""")
MAV_COMP_ID_SERVO2 = 141
enums["MAV_COMPONENT"][141] = EnumEntry("MAV_COMP_ID_SERVO2", """Servo #2.""")
MAV_COMP_ID_SERVO3 = 142
enums["MAV_COMPONENT"][142] = EnumEntry("MAV_COMP_ID_SERVO3", """Servo #3.""")
MAV_COMP_ID_SERVO4 = 143
enums["MAV_COMPONENT"][143] = EnumEntry("MAV_COMP_ID_SERVO4", """Servo #4.""")
MAV_COMP_ID_SERVO5 = 144
enums["MAV_COMPONENT"][144] = EnumEntry("MAV_COMP_ID_SERVO5", """Servo #5.""")
MAV_COMP_ID_SERVO6 = 145
enums["MAV_COMPONENT"][145] = EnumEntry("MAV_COMP_ID_SERVO6", """Servo #6.""")
MAV_COMP_ID_SERVO7 = 146
enums["MAV_COMPONENT"][146] = EnumEntry("MAV_COMP_ID_SERVO7", """Servo #7.""")
MAV_COMP_ID_SERVO8 = 147
enums["MAV_COMPONENT"][147] = EnumEntry("MAV_COMP_ID_SERVO8", """Servo #8.""")
MAV_COMP_ID_SERVO9 = 148
enums["MAV_COMPONENT"][148] = EnumEntry("MAV_COMP_ID_SERVO9", """Servo #9.""")
MAV_COMP_ID_SERVO10 = 149
enums["MAV_COMPONENT"][149] = EnumEntry("MAV_COMP_ID_SERVO10", """Servo #10.""")
MAV_COMP_ID_SERVO11 = 150
enums["MAV_COMPONENT"][150] = EnumEntry("MAV_COMP_ID_SERVO11", """Servo #11.""")
MAV_COMP_ID_SERVO12 = 151
enums["MAV_COMPONENT"][151] = EnumEntry("MAV_COMP_ID_SERVO12", """Servo #12.""")
MAV_COMP_ID_SERVO13 = 152
enums["MAV_COMPONENT"][152] = EnumEntry("MAV_COMP_ID_SERVO13", """Servo #13.""")
MAV_COMP_ID_SERVO14 = 153
enums["MAV_COMPONENT"][153] = EnumEntry("MAV_COMP_ID_SERVO14", """Servo #14.""")
MAV_COMP_ID_GIMBAL = 154
enums["MAV_COMPONENT"][154] = EnumEntry("MAV_COMP_ID_GIMBAL", """Gimbal #1.""")
MAV_COMP_ID_LOG = 155
enums["MAV_COMPONENT"][155] = EnumEntry("MAV_COMP_ID_LOG", """Logging component.""")
MAV_COMP_ID_ADSB = 156
enums["MAV_COMPONENT"][156] = EnumEntry("MAV_COMP_ID_ADSB", """Automatic Dependent Surveillance-Broadcast (ADS-B) component.""")
MAV_COMP_ID_OSD = 157
enums["MAV_COMPONENT"][157] = EnumEntry("MAV_COMP_ID_OSD", """On Screen Display (OSD) devices for video links.""")
MAV_COMP_ID_PERIPHERAL = 158
enums["MAV_COMPONENT"][158] = EnumEntry("MAV_COMP_ID_PERIPHERAL", """Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter microservice.""")
MAV_COMP_ID_QX1_GIMBAL = 159
enums["MAV_COMPONENT"][159] = EnumEntry("MAV_COMP_ID_QX1_GIMBAL", """Gimbal ID for QX1.""")
MAV_COMP_ID_FLARM = 160
enums["MAV_COMPONENT"][160] = EnumEntry("MAV_COMP_ID_FLARM", """FLARM collision alert component.""")
MAV_COMP_ID_PARACHUTE = 161
enums["MAV_COMPONENT"][161] = EnumEntry("MAV_COMP_ID_PARACHUTE", """Parachute component.""")
MAV_COMP_ID_GIMBAL2 = 171
enums["MAV_COMPONENT"][171] = EnumEntry("MAV_COMP_ID_GIMBAL2", """Gimbal #2.""")
MAV_COMP_ID_GIMBAL3 = 172
enums["MAV_COMPONENT"][172] = EnumEntry("MAV_COMP_ID_GIMBAL3", """Gimbal #3.""")
MAV_COMP_ID_GIMBAL4 = 173
enums["MAV_COMPONENT"][173] = EnumEntry("MAV_COMP_ID_GIMBAL4", """Gimbal #4""")
MAV_COMP_ID_GIMBAL5 = 174
enums["MAV_COMPONENT"][174] = EnumEntry("MAV_COMP_ID_GIMBAL5", """Gimbal #5.""")
MAV_COMP_ID_GIMBAL6 = 175
enums["MAV_COMPONENT"][175] = EnumEntry("MAV_COMP_ID_GIMBAL6", """Gimbal #6.""")
MAV_COMP_ID_BATTERY = 180
enums["MAV_COMPONENT"][180] = EnumEntry("MAV_COMP_ID_BATTERY", """Battery #1.""")
MAV_COMP_ID_BATTERY2 = 181
enums["MAV_COMPONENT"][181] = EnumEntry("MAV_COMP_ID_BATTERY2", """Battery #2.""")
MAV_COMP_ID_MAVCAN = 189
enums["MAV_COMPONENT"][189] = EnumEntry("MAV_COMP_ID_MAVCAN", """CAN over MAVLink client.""")
MAV_COMP_ID_MISSIONPLANNER = 190
enums["MAV_COMPONENT"][190] = EnumEntry("MAV_COMP_ID_MISSIONPLANNER", """Component that can generate/supply a mission flight plan (e.g. GCS or developer API).""")
MAV_COMP_ID_ONBOARD_COMPUTER = 191
enums["MAV_COMPONENT"][191] = EnumEntry("MAV_COMP_ID_ONBOARD_COMPUTER", """Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.""")
MAV_COMP_ID_ONBOARD_COMPUTER2 = 192
enums["MAV_COMPONENT"][192] = EnumEntry("MAV_COMP_ID_ONBOARD_COMPUTER2", """Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.""")
MAV_COMP_ID_ONBOARD_COMPUTER3 = 193
enums["MAV_COMPONENT"][193] = EnumEntry("MAV_COMP_ID_ONBOARD_COMPUTER3", """Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.""")
MAV_COMP_ID_ONBOARD_COMPUTER4 = 194
enums["MAV_COMPONENT"][194] = EnumEntry("MAV_COMP_ID_ONBOARD_COMPUTER4", """Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.""")
MAV_COMP_ID_PATHPLANNER = 195
enums["MAV_COMPONENT"][195] = EnumEntry("MAV_COMP_ID_PATHPLANNER", """Component that finds an optimal path between points based on a certain constraint (e.g. minimum snap, shortest path, cost, etc.).""")
MAV_COMP_ID_OBSTACLE_AVOIDANCE = 196
enums["MAV_COMPONENT"][196] = EnumEntry("MAV_COMP_ID_OBSTACLE_AVOIDANCE", """Component that plans a collision free path between two points.""")
MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY = 197
enums["MAV_COMPONENT"][197] = EnumEntry("MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY", """Component that provides position estimates using VIO techniques.""")
MAV_COMP_ID_PAIRING_MANAGER = 198
enums["MAV_COMPONENT"][198] = EnumEntry("MAV_COMP_ID_PAIRING_MANAGER", """Component that manages pairing of vehicle and GCS.""")
MAV_COMP_ID_IMU = 200
enums["MAV_COMPONENT"][200] = EnumEntry("MAV_COMP_ID_IMU", """Inertial Measurement Unit (IMU) #1.""")
MAV_COMP_ID_IMU_2 = 201
enums["MAV_COMPONENT"][201] = EnumEntry("MAV_COMP_ID_IMU_2", """Inertial Measurement Unit (IMU) #2.""")
MAV_COMP_ID_IMU_3 = 202
enums["MAV_COMPONENT"][202] = EnumEntry("MAV_COMP_ID_IMU_3", """Inertial Measurement Unit (IMU) #3.""")
MAV_COMP_ID_GPS = 220
enums["MAV_COMPONENT"][220] = EnumEntry("MAV_COMP_ID_GPS", """GPS #1.""")
MAV_COMP_ID_GPS2 = 221
enums["MAV_COMPONENT"][221] = EnumEntry("MAV_COMP_ID_GPS2", """GPS #2.""")
MAV_COMP_ID_ODID_TXRX_1 = 236
enums["MAV_COMPONENT"][236] = EnumEntry("MAV_COMP_ID_ODID_TXRX_1", """Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).""")
MAV_COMP_ID_ODID_TXRX_2 = 237
enums["MAV_COMPONENT"][237] = EnumEntry("MAV_COMP_ID_ODID_TXRX_2", """Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).""")
MAV_COMP_ID_ODID_TXRX_3 = 238
enums["MAV_COMPONENT"][238] = EnumEntry("MAV_COMP_ID_ODID_TXRX_3", """Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).""")
MAV_COMP_ID_UDP_BRIDGE = 240
enums["MAV_COMPONENT"][240] = EnumEntry("MAV_COMP_ID_UDP_BRIDGE", """Component to bridge MAVLink to UDP (i.e. from a UART).""")
MAV_COMP_ID_UART_BRIDGE = 241
enums["MAV_COMPONENT"][241] = EnumEntry("MAV_COMP_ID_UART_BRIDGE", """Component to bridge to UART (i.e. from UDP).""")
MAV_COMP_ID_TUNNEL_NODE = 242
enums["MAV_COMPONENT"][242] = EnumEntry("MAV_COMP_ID_TUNNEL_NODE", """Component handling TUNNEL messages (e.g. vendor specific GUI of a component).""")
MAV_COMP_ID_SYSTEM_CONTROL = 250
enums["MAV_COMPONENT"][250] = EnumEntry("MAV_COMP_ID_SYSTEM_CONTROL", """Component for handling system messages (e.g. to ARM, takeoff, etc.).""")
MAV_COMPONENT_ENUM_END = 251
enums["MAV_COMPONENT"][251] = EnumEntry("MAV_COMPONENT_ENUM_END", """""")
# message IDs
MAVLINK_MSG_ID_GPS_RAW_INT = 24
MAVLINK_MSG_ID_COMMAND_LONG = 76
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_UNKNOWN = -2
MAVLINK_MSG_ID_HEARTBEAT = 0
MAVLINK_MSG_ID_PROTOCOL_VERSION = 300
MAVLINK_MSG_ID_MISSION_ITEM = 39
MAVLINK_MSG_ID_MISSION_REQUEST = 40
MAVLINK_MSG_ID_MISSION_SET_CURRENT = 41
MAVLINK_MSG_ID_MISSION_CURRENT = 42
MAVLINK_MSG_ID_MISSION_REQUEST_LIST = 43
MAVLINK_MSG_ID_MISSION_COUNT = 44
MAVLINK_MSG_ID_MISSION_CLEAR_ALL = 45
MAVLINK_MSG_ID_MISSION_ITEM_REACHED = 46


class MAVLink_heartbeat_message(MAVLink_message):
    """
    The heartbeat message shows that a system or component is present
    and responding. The type and autopilot fields (along with the
    message component id), allow the receiving system to treat further
    messages from this system appropriately (e.g. by laying out the
    user interface based on the autopilot). This microservice is
    documented at https://mavlink.io/en/services/heartbeat.html
    """

    id = MAVLINK_MSG_ID_HEARTBEAT
    name = "HEARTBEAT"
    fieldnames = ["type", "autopilot", "base_mode", "custom_mode", "system_status", "mavlink_version"]
    ordered_fieldnames = ["custom_mode", "type", "autopilot", "base_mode", "system_status", "mavlink_version"]
    fieldtypes = ["uint8_t", "uint8_t", "uint8_t", "uint32_t", "uint8_t", "uint8_t"]
    fielddisplays_by_name = {"base_mode": "bitmask"}
    fieldenums_by_name = {"type": "MAV_TYPE", "autopilot": "MAV_AUTOPILOT", "base_mode": "MAV_MODE_FLAG", "system_status": "MAV_STATE"}
    fieldunits_by_name = {}
    format = "<IBBBBB"
    native_format = bytearray("<IBBBBB", "ascii")
    orders = [1, 2, 3, 0, 4, 5]
    lengths = [1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0]
    crc_extra = 50

    instance_field = None
    instance_offset = -1

    def __init__(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version):
        MAVLink_message.__init__(self, MAVLink_heartbeat_message.id, MAVLink_heartbeat_message.name)
        self._fieldnames = MAVLink_heartbeat_message.fieldnames
        self._instance_field = MAVLink_heartbeat_message.instance_field
        self._instance_offset = MAVLink_heartbeat_message.instance_offset
        self.type = type
        self.autopilot = autopilot
        self.base_mode = base_mode
        self.custom_mode = custom_mode
        self.system_status = system_status
        self.mavlink_version = mavlink_version

    def pack(self, mav, force_mavlink1=False):
        return MAVLink_message.pack(self, mav, 50, ustruct.pack("<IBBBBB", self.custom_mode, self.type, self.autopilot, self.base_mode, self.system_status, self.mavlink_version), force_mavlink1=force_mavlink1)



class MAVLink_mission_item_message(MAVLink_message):
    """
    Message encoding a mission item. This message is emitted to
    announce                 the presence of a mission item and to set
    a mission item on the system. The mission item can be either in x,
    y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame
    is Z-down, right handed (NED), global frame is Z-up, right handed
    (ENU). NaN may be used to indicate an optional/default value (e.g.
    to use the system's current latitude or yaw rather than a specific
    value). See also https://mavlink.io/en/services/mission.html.
    """

    id = MAVLINK_MSG_ID_MISSION_ITEM
    name = "MISSION_ITEM"
    fieldnames = ["target_system", "target_component", "seq", "frame", "command", "current", "autocontinue", "param1", "param2", "param3", "param4", "x", "y", "z", "mission_type"]
    ordered_fieldnames = ["param1", "param2", "param3", "param4", "x", "y", "z", "seq", "command", "target_system", "target_component", "frame", "current", "autocontinue", "mission_type"]
    fieldtypes = ["uint8_t", "uint8_t", "uint16_t", "uint8_t", "uint16_t", "uint8_t", "uint8_t", "float", "float", "float", "float", "float", "float", "float", "uint8_t"]
    fielddisplays_by_name = {}
    fieldenums_by_name = {"frame": "MAV_FRAME", "command": "MAV_CMD", "mission_type": "MAV_MISSION_TYPE"}
    fieldunits_by_name = {}
    format = "<fffffffHHBBBBBB"
    native_format = bytearray("<fffffffHHBBBBBB", "ascii")
    orders = [9, 10, 7, 11, 8, 12, 13, 0, 1, 2, 3, 4, 5, 6, 14]
    lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    crc_extra = 254
    instance_field = None
    instance_offset = -1

    def __init__(self, target_system, target_component, seq, frame, command, current, autocontinue, param1, param2, param3, param4, x, y, z, mission_type=0):
        MAVLink_message.__init__(self, MAVLink_mission_item_message.id, MAVLink_mission_item_message.name)
        self._fieldnames = MAVLink_mission_item_message.fieldnames
        self._instance_field = MAVLink_mission_item_message.instance_field
        self._instance_offset = MAVLink_mission_item_message.instance_offset
        self.target_system = target_system
        self.target_component = target_component
        self.seq = seq
        self.frame = frame
        self.command = command
        self.current = current
        self.autocontinue = autocontinue
        self.param1 = param1
        self.param2 = param2
        self.param3 = param3
        self.param4 = param4
        self.x = x
        self.y = y
        self.z = z
        self.mission_type = mission_type

    def pack(self, mav, force_mavlink1=False):
        return MAVLink_message.pack(self, mav, 254, ustruct.pack("<fffffffHHBBBBBB", self.param1, self.param2, self.param3, self.param4, self.x, self.y, self.z, self.seq, self.command, self.target_system, self.target_component, self.frame, self.current, self.autocontinue, self.mission_type), force_mavlink1=force_mavlink1)


class MAVLink_protocol_version_message(MAVLink_message):
    """
    Version and capability of protocol version. This message can be
    requested with MAV_CMD_REQUEST_MESSAGE and is used as part of the
    handshaking to establish which MAVLink version should be used on
    the network. Every node should respond to a request for
    PROTOCOL_VERSION to enable the handshaking. Library implementers
    should consider adding this into the default decoding state
    machine to allow the protocol core to respond directly.
    """

    id = MAVLINK_MSG_ID_PROTOCOL_VERSION
    name = "PROTOCOL_VERSION"
    fieldnames = ["version", "min_version", "max_version", "spec_version_hash", "library_version_hash"]
    ordered_fieldnames = ["version", "min_version", "max_version", "spec_version_hash", "library_version_hash"]
    fieldtypes = ["uint16_t", "uint16_t", "uint16_t", "uint8_t", "uint8_t"]
    fielddisplays_by_name = {}
    fieldenums_by_name = {}
    fieldunits_by_name = {}
    format = "<HHH8B8B"
    native_format = bytearray("<HHHBB", "ascii")
    orders = [0, 1, 2, 3, 4]
    lengths = [1, 1, 1, 8, 8]
    array_lengths = [0, 0, 0, 8, 8]
    crc_extra = 217

    instance_field = None
    instance_offset = -1

    def __init__(self, version, min_version, max_version, spec_version_hash, library_version_hash):
        MAVLink_message.__init__(self, MAVLink_protocol_version_message.id, MAVLink_protocol_version_message.name)
        self._fieldnames = MAVLink_protocol_version_message.fieldnames
        self._instance_field = MAVLink_protocol_version_message.instance_field
        self._instance_offset = MAVLink_protocol_version_message.instance_offset
        self.version = version
        self.min_version = min_version
        self.max_version = max_version
        self.spec_version_hash = spec_version_hash
        self.library_version_hash = library_version_hash

    def pack(self, mav, force_mavlink1=False):
        return MAVLink_message.pack(self, mav, 217, ustruct.pack("<HHH8B8B", self.version, self.min_version, self.max_version, self.spec_version_hash[0], self.spec_version_hash[1], self.spec_version_hash[2], self.spec_version_hash[3], self.spec_version_hash[4], self.spec_version_hash[5], self.spec_version_hash[6], self.spec_version_hash[7], self.library_version_hash[0], self.library_version_hash[1], self.library_version_hash[2], self.library_version_hash[3], self.library_version_hash[4], self.library_version_hash[5], self.library_version_hash[6], self.library_version_hash[7]), force_mavlink1=force_mavlink1)


mavlink_map = {
    MAVLINK_MSG_ID_HEARTBEAT: MAVLink_heartbeat_message,
    MAVLINK_MSG_ID_PROTOCOL_VERSION: MAVLink_protocol_version_message,
}


class MAVError(Exception):
    """MAVLink error class"""

    def __init__(self, msg):
        Exception.__init__(self, msg)
        self.message = msg


class MAVString(str):
    """NUL terminated string"""

    def __init__(self, s):
        str.__init__(self)

    def __str__(self):
        i = self.find(chr(0))
        if i == -1:
            return self[:]
        return self[0:i]

class MAVLink_gps_raw_int_message(MAVLink_message):
    """
    The global position, as returned by the Global Positioning System
    (GPS). This is                 NOT the global position estimate of
    the system, but rather a RAW sensor value. See message
    GLOBAL_POSITION for the global position estimate.
    """

    id = MAVLINK_MSG_ID_GPS_RAW_INT
    name = "GPS_RAW_INT"
    fieldnames = ["time_usec", "fix_type", "lat", "lon", "alt", "eph", "epv", "vel", "cog", "satellites_visible", "alt_ellipsoid", "h_acc", "v_acc", "vel_acc", "hdg_acc", "yaw"]
    ordered_fieldnames = ["time_usec", "lat", "lon", "alt", "eph", "epv", "vel", "cog", "fix_type", "satellites_visible", "alt_ellipsoid", "h_acc", "v_acc", "vel_acc", "hdg_acc", "yaw"]
    fieldtypes = ["uint64_t", "uint8_t", "int32_t", "int32_t", "int32_t", "uint16_t", "uint16_t", "uint16_t", "uint16_t", "uint8_t", "int32_t", "uint32_t", "uint32_t", "uint32_t", "uint32_t", "uint16_t"]
    fielddisplays_by_name = {}
    fieldenums_by_name = {"fix_type": "GPS_FIX_TYPE"}
    fieldunits_by_name = {"time_usec": "us", "lat": "degE7", "lon": "degE7", "alt": "mm", "vel": "cm/s", "cog": "cdeg", "alt_ellipsoid": "mm", "h_acc": "mm", "v_acc": "mm", "vel_acc": "mm", "hdg_acc": "degE5", "yaw": "cdeg"}
    format = "<QiiiHHHHBBiIIIIH"
    native_format = bytearray("<QiiiHHHHBBiIIIIH", "ascii")
    orders = [0, 8, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15]
    lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    crc_extra = 24
    instance_field = None
    instance_offset = -1

    def __init__(self, time_usec, fix_type, lat, lon, alt, eph, epv, vel, cog, satellites_visible, alt_ellipsoid=0, h_acc=0, v_acc=0, vel_acc=0, hdg_acc=0, yaw=0):
        MAVLink_message.__init__(self, MAVLink_gps_raw_int_message.id, MAVLink_gps_raw_int_message.name)
        self._fieldnames = MAVLink_gps_raw_int_message.fieldnames
        self._instance_field = MAVLink_gps_raw_int_message.instance_field
        self._instance_offset = MAVLink_gps_raw_int_message.instance_offset
        self.time_usec = time_usec
        self.fix_type = fix_type
        self.lat = lat
        self.lon = lon
        self.alt = alt
        self.eph = eph
        self.epv = epv
        self.vel = vel
        self.cog = cog
        self.satellites_visible = satellites_visible
        self.alt_ellipsoid = alt_ellipsoid
        self.h_acc = h_acc
        self.v_acc = v_acc
        self.vel_acc = vel_acc
        self.hdg_acc = hdg_acc
        self.yaw = yaw

    def pack(self, mav, force_mavlink1=False):
        return MAVLink_message.pack(self, mav, 24, ustruct.pack("<QiiiHHHHBBiIIIIH", self.time_usec, self.lat, self.lon, self.alt, self.eph, self.epv, self.vel, self.cog, self.fix_type, self.satellites_visible, self.alt_ellipsoid, self.h_acc, self.v_acc, self.vel_acc, self.hdg_acc, self.yaw), force_mavlink1=force_mavlink1)


class MAVLink_bad_data(MAVLink_message):
    """
    a piece of bad data in a mavlink stream
    """

    def __init__(self, data, reason):
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, "BAD_DATA")
        self._fieldnames = ["data", "reason"]
        self.data = data
        self.reason = reason
        self._msgbuf = data
        self._instance_field = None

    def __str__(self):
        """Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist."""
        return "%s {%s, data:%s}" % (self._type, self.reason, [("%x" % ord(i) if isinstance(i, str) else "%x" % i) for i in self.data])


class MAVLink_unknown(MAVLink_message):
    """
    a message that we don't have in the XML used when built
    """

    def __init__(self, msgid, data):
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_UNKNOWN, "UNKNOWN_%u" % msgid)
        self._fieldnames = ["data"]
        self.data = data
        self._msgbuf = data
        self._instance_field = None

    def __str__(self):
        """Override the __str__ function from MAVLink_messages because non-printable characters are common."""
        return "%s {data:%s}" % (self._type, [("%x" % ord(i) if isinstance(i, str) else "%x" % i) for i in self.data])


class MAVLinkSigning(object):
    """MAVLink signing state class"""

    def __init__(self):
        self.secret_key = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback = None
        self.stream_timestamps = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0

class MAVLink_command_long_message(MAVLink_message):
    """
    Send a command with up to seven parameters to the MAV. The command
    microservice is documented at
    https://mavlink.io/en/services/command.html
    """

    id = MAVLINK_MSG_ID_COMMAND_LONG
    name = "COMMAND_LONG"
    fieldnames = ["target_system", "target_component", "command", "confirmation", "param1", "param2", "param3", "param4", "param5", "param6", "param7"]
    ordered_fieldnames = ["param1", "param2", "param3", "param4", "param5", "param6", "param7", "command", "target_system", "target_component", "confirmation"]
    fieldtypes = ["uint8_t", "uint8_t", "uint16_t", "uint8_t", "float", "float", "float", "float", "float", "float", "float"]
    fielddisplays_by_name = {}
    fieldenums_by_name = {"command": "MAV_CMD"}
    fieldunits_by_name = {}
    format = "<fffffffHBBB"
    native_format = bytearray("<fffffffHBBB", "ascii")
    orders = [8, 9, 7, 10, 0, 1, 2, 3, 4, 5, 6]
    lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    crc_extra = 152
    instance_field = None
    instance_offset = -1

    def __init__(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7):
        MAVLink_message.__init__(self, MAVLink_command_long_message.id, MAVLink_command_long_message.name)
        self._fieldnames = MAVLink_command_long_message.fieldnames
        self._instance_field = MAVLink_command_long_message.instance_field
        self._instance_offset = MAVLink_command_long_message.instance_offset
        self.target_system = target_system
        self.target_component = target_component
        self.command = command
        self.confirmation = confirmation
        self.param1 = param1
        self.param2 = param2
        self.param3 = param3
        self.param4 = param4
        self.param5 = param5
        self.param6 = param6
        self.param7 = param7

    def pack(self, mav, force_mavlink1=False):
        return MAVLink_message.pack(self, mav, 152, ustruct.pack("<fffffffHBBB", self.param1, self.param2, self.param3, self.param4, self.param5, self.param6, self.param7, self.command, self.target_system, self.target_component, self.confirmation), force_mavlink1=force_mavlink1)


class MAVLink(object):
    """MAVLink protocol handling class"""

    def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
        self.seq = 0
        self.file = file
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.callback = None
        self.callback_args = None
        self.callback_kwargs = None
        self.send_callback = None
        self.send_callback_args = None
        self.send_callback_kwargs = None
        self.buf = bytearray()
        self.buf_index = 0
        self.expected_length = HEADER_LEN_V1 + 2
        self.have_prefix_error = False
        self.robust_parsing = False
        self.protocol_marker = 253
        self.little_endian = True
        self.crc_extra = True
        self.sort_fields = True
        self.total_packets_sent = 0
        self.total_bytes_sent = 0
        self.total_packets_received = 0
        self.total_bytes_received = 0
        self.total_receive_errors = 0
        self.startup_time = time.time()
        self.signing = MAVLinkSigning()
        self.native = False
        if native_testing:
            self.test_buf = bytearray()


    def command_long_send(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7, force_mavlink1=False):
        """
        Send a command with up to seven parameters to the MAV. The command
        microservice is documented at
        https://mavlink.io/en/services/command.html

        target_system             : System which should execute the command (type:uint8_t)
        target_component          : Component which should execute the command, 0 for all components (type:uint8_t)
        command                   : Command ID (of command to send). (type:uint16_t, values:MAV_CMD)
        confirmation              : 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) (type:uint8_t)
        param1                    : Parameter 1 (for the specific command). (type:float)
        param2                    : Parameter 2 (for the specific command). (type:float)
        param3                    : Parameter 3 (for the specific command). (type:float)
        param4                    : Parameter 4 (for the specific command). (type:float)
        param5                    : Parameter 5 (for the specific command). (type:float)
        param6                    : Parameter 6 (for the specific command). (type:float)
        param7                    : Parameter 7 (for the specific command). (type:float)

        """
        return self.send(self.command_long_encode(target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7), force_mavlink1=force_mavlink1)

    def command_long_encode(self, target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7):
        """
        Send a command with up to seven parameters to the MAV. The command
        microservice is documented at
        https://mavlink.io/en/services/command.html

        target_system             : System which should execute the command (type:uint8_t)
        target_component          : Component which should execute the command, 0 for all components (type:uint8_t)
        command                   : Command ID (of command to send). (type:uint16_t, values:MAV_CMD)
        confirmation              : 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command) (type:uint8_t)
        param1                    : Parameter 1 (for the specific command). (type:float)
        param2                    : Parameter 2 (for the specific command). (type:float)
        param3                    : Parameter 3 (for the specific command). (type:float)
        param4                    : Parameter 4 (for the specific command). (type:float)
        param5                    : Parameter 5 (for the specific command). (type:float)
        param6                    : Parameter 6 (for the specific command). (type:float)
        param7                    : Parameter 7 (for the specific command). (type:float)

        """
        return MAVLink_command_long_message(target_system, target_component, command, confirmation, param1, param2, param3, param4, param5, param6, param7)



    def set_callback(self, callback, *args, **kwargs):
        self.callback = callback
        self.callback_args = args
        self.callback_kwargs = kwargs

    def set_send_callback(self, callback, *args, **kwargs):
        self.send_callback = callback
        self.send_callback_args = args
        self.send_callback_kwargs = kwargs

    def send(self, mavmsg, force_mavlink1=False):
        """send a MAVLink message"""
        buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
        self.file.write(buf)
        self.seq = (self.seq + 1) % 256
        self.total_packets_sent += 1
        self.total_bytes_sent += len(buf)
        if self.send_callback:
            self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

    def buf_len(self):
        return len(self.buf) - self.buf_index

    def bytes_needed(self):
        """return number of bytes needed for next parsing stage"""
        if self.native:
            ret = self.native.expected_length - self.buf_len()
        else:
            ret = self.expected_length - self.buf_len()

        if ret <= 0:
            return 1
        return ret

    def __parse_char_native(self, c):
        """this method exists only to see in profiling results"""
        m = self.native.parse_chars(c)
        return m

    def __callbacks(self, msg):
        """this method exists only to make profiling results easier to read"""
        if self.callback:
            self.callback(msg, *self.callback_args, **self.callback_kwargs)

    def parse_char(self, c):
        """input some data bytes, possibly returning a new message"""
        self.buf.extend(c)

        self.total_bytes_received += len(c)

        if self.native:
            if native_testing:
                self.test_buf.extend(c)
                m = self.__parse_char_native(self.test_buf)
                m2 = self.__parse_char_legacy()
                if m2 != m:
                    print("Native: %s\nLegacy: %s\n" % (m, m2))
                    raise Exception("Native vs. Legacy mismatch")
            else:
                m = self.__parse_char_native(self.buf)
        else:
            m = self.__parse_char_legacy()

        if m is not None:
            self.total_packets_received += 1
            self.__callbacks(m)
        else:
            # XXX The idea here is if we've read something and there's nothing left in
            # the buffer, reset it to 0 which frees the memory
            if self.buf_len() == 0 and self.buf_index != 0:
                self.buf = bytearray()
                self.buf_index = 0

        return m

    def __parse_char_legacy(self):
        """input some data bytes, possibly returning a new message (uses no native code)"""
        header_len = HEADER_LEN_V1
        if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
            header_len = HEADER_LEN_V2

        if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
            magic = self.buf[self.buf_index]
            self.buf_index += 1
            if self.robust_parsing:
                m = MAVLink_bad_data(bytearray([magic]), "Bad prefix")
                self.expected_length = header_len + 2
                self.total_receive_errors += 1
                return m
            if self.have_prefix_error:
                return None
            self.have_prefix_error = True
            self.total_receive_errors += 1
            raise MAVError("invalid MAVLink prefix '%s'" % magic)
        self.have_prefix_error = False
        if self.buf_len() >= 3:
            sbuf = self.buf[self.buf_index : 3 + self.buf_index]
            #if sys.version_info.major < 3:
            #    sbuf = str(sbuf)
            (magic, self.expected_length, incompat_flags) = ustruct.unpack("BBB",sbuf)
            if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
            self.expected_length += header_len + 2
        if self.expected_length >= (header_len + 2) and self.buf_len() >= self.expected_length:
            mbuf = array.array("B", self.buf[self.buf_index : self.buf_index + self.expected_length])
            self.buf_index += self.expected_length
            self.expected_length = header_len + 2
            if self.robust_parsing:
                try:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                except MAVError as reason:
                    m = MAVLink_bad_data(mbuf, reason.message)
                    self.total_receive_errors += 1
            else:
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                    raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                m = self.decode(mbuf)
            return m
        return None

    def parse_buffer(self, s):
        """input some data bytes, possibly returning a list of new messages"""
        m = self.parse_char(s)
        if m is None:
            return None
        ret = [m]
        while True:
            m = self.parse_char("")
            if m is None:
                return ret
            ret.append(m)
        return ret

    def check_signature(self, msgbuf, srcSystem, srcComponent):
        """check signature on incoming message"""
        if isinstance(msgbuf, array.array):
            try:
                msgbuf = msgbuf.tostring()
            except:
                msgbuf = msgbuf.tobytes()
        timestamp_buf = msgbuf[-12:-6]
        link_id = msgbuf[-13]
        (tlow, thigh) = ustruct.unpack("<IH",timestamp_buf)
        timestamp = tlow + (thigh << 32)

        # see if the timestamp is acceptable
        stream_key = (link_id, srcSystem, srcComponent)
        if stream_key in self.signing.stream_timestamps:
            if timestamp <= self.signing.stream_timestamps[stream_key]:
                # reject old timestamp
                # print("old timestamp")
                return False
        else:
            # a new stream has appeared. Accept the timestamp if it is at most
            # one minute behind our current timestamp
            if timestamp + 6000 * 1000 < self.signing.timestamp:
                # print("bad new stream ", timestamp/(100.0 * 1000 * 60 * 60 * 24 * 365), self.signing.timestamp/(100.0 * 1000 * 60 * 60 * 24 * 365))
                return False
            self.signing.stream_timestamps[stream_key] = timestamp
            # print("new stream")

        h = hashlib.new("sha256")
        h.update(self.signing.secret_key)
        h.update(msgbuf[:-6])
        if str(type(msgbuf)) == "<class 'bytes'>" or str(type(msgbuf)) == "<class 'bytearray'>":
            # Python 3
            sig1 = h.digest()[:6]
            sig2 = msgbuf[-6:]
        else:
            sig1 = str(h.digest())[:6]
            sig2 = str(msgbuf)[-6:]
        if sig1 != sig2:
            # print("sig mismatch")
            return False

        # the timestamp we next send with is the max of the received timestamp and
        # our current timestamp
        self.signing.timestamp = max(self.signing.timestamp, timestamp)
        return True

    def decode(self, msgbuf):
        """decode a buffer as a MAVLink message"""
        # decode the header
        if msgbuf[0] != PROTOCOL_MARKER_V1:
            headerlen = 10
            try:
                magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = ustruct.unpack("<cBBBBBBHB",msgbuf[:headerlen])
            except:
                raise MAVError("Unable to unpack MAVLink header")
            msgId = msgIdlow | (msgIdhigh << 16)
            mapkey = msgId
        else:
            headerlen = 6
            ## --FIX--
            #try:
            #    magic, mlen, seq, srcSystem, srcComponent, msgId = ustruct.unpack("<cBBBBB",msgbuf[:headerlen])
            #    incompat_flags = 0
            #    compat_flags = 0
            #except:
            #    raise MAVError("Unable to unpack MAVLink header")
            magic, mlen, seq, srcSystem, srcComponent, msgId = ustruct.unpack("<BBBBBB",msgbuf[:headerlen])
            print(magic)
            incompat_flags = 0
            compat_flags = 0
            
            
            mapkey = msgId
        if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
            signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
        else:
            signature_len = 0

        if magic != PROTOCOL_MARKER_V1 and magic != PROTOCOL_MARKER_V2:
            raise MAVError("invalid MAVLink prefix '%s'" % magic)
        if mlen != len(msgbuf) - (headerlen + 2 + signature_len):
            raise MAVError("invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u" % (len(msgbuf) - (headerlen + 2 + signature_len), mlen, msgId, headerlen))

        if not mapkey in mavlink_map:
            return MAVLink_unknown(msgId, msgbuf)

        # decode the payload
        type = mavlink_map[mapkey]
        fmt = type.format
        order_map = type.orders
        len_map = type.lengths
        crc_extra = type.crc_extra

        # decode the checksum
        try:
            (crc,) = ustruct.unpack("<H",msgbuf[-(2 + signature_len) :][:2])
        except:
            raise MAVError("Unable to unpack MAVLink CRC")
        crcbuf = msgbuf[1 : -(2 + signature_len)]
        if True:
            # using CRC extra
            crcbuf.append(crc_extra)
        crc2 = x25crc(crcbuf)
        if crc != crc2.crc and not MAVLINK_IGNORE_CRC:
            raise MAVError("invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x" % (msgId, crc, crc2.crc))

        sig_ok = False
        if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
            self.signing.sig_count += 1
        if self.signing.secret_key is not None:
            accept_signature = False
            if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                accept_signature = sig_ok
                if sig_ok:
                    self.signing.goodsig_count += 1
                else:
                    self.signing.badsig_count += 1
                if not accept_signature and self.signing.allow_unsigned_callback is not None:
                    accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                    if accept_signature:
                        self.signing.unsigned_count += 1
                    else:
                        self.signing.reject_count += 1
            elif self.signing.allow_unsigned_callback is not None:
                accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                if accept_signature:
                    self.signing.unsigned_count += 1
                else:
                    self.signing.reject_count += 1
            if not accept_signature:
                raise MAVError("Invalid signature")

        csize = ustruct.calcsize(type.format)
        mbuf = msgbuf[headerlen : -(2 + signature_len)]
        if len(mbuf) < csize:
            # zero pad to give right size
            mbuf.extend([0] * (csize - len(mbuf)))
        if len(mbuf) < csize:
            raise MAVError("Bad message of type %s length %u needs %s" % (type, len(mbuf), csize))
        mbuf = mbuf[:csize]
        try:
            t = ustruct.unpack(type.format,mbuf)
        except:
            raise MAVError("Unable to unpack MAVLink payload")

        tlist = list(t)
        # handle sorted fields
        if True:
            t = tlist[:]
            if sum(len_map) == len(len_map):
                # message has no arrays in it
                for i in range(0, len(tlist)):
                    tlist[i] = t[order_map[i]]
            else:
                # message has some arrays
                tlist = []
                for i in range(0, len(order_map)):
                    order = order_map[i]
                    L = len_map[order]
                    tip = sum(len_map[:order])
                    field = t[tip]
                    if L == 1 or isinstance(field, str):
                        tlist.append(field)
                    else:
                        tlist.append(t[tip : (tip + L)])

        # terminate any strings
        for i in range(0, len(tlist)):
            if type.fieldtypes[i] == "char":
                if sys.version_info.major >= 3:
                    tlist[i] = to_string(tlist[i])
                tlist[i] = str(MAVString(tlist[i]))
        t = tuple(tlist)
        # conustruct the message object
        try:
            m = type(*t)
        except Exception as emsg:
            raise MAVError("Unable to instantiate MAVLink message of type %s : %s" % (type, emsg))
        m._signed = sig_ok
        if m._signed:
            m._link_id = msgbuf[-13]
        m._msgbuf = msgbuf
        m._payload = msgbuf[6 : -(2 + signature_len)]
        m._crc = crc
        m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
        return m

    def heartbeat_encode(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version=3):
        """
        The heartbeat message shows that a system or component is present and
        responding. The type and autopilot fields (along with the
        message component id), allow the receiving system to treat
        further messages from this system appropriately (e.g. by
        laying out the user interface based on the autopilot). This
        microservice is documented at
        https://mavlink.io/en/services/heartbeat.html

        type                      : Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type. (type:uint8_t, values:MAV_TYPE)
        autopilot                 : Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers. (type:uint8_t, values:MAV_AUTOPILOT)
        base_mode                 : System mode bitmap. (type:uint8_t, values:MAV_MODE_FLAG)
        custom_mode               : A bitfield for use for autopilot-specific flags (type:uint32_t)
        system_status             : System status flag. (type:uint8_t, values:MAV_STATE)
        mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (type:uint8_t)

        """
        return MAVLink_heartbeat_message(type, autopilot, base_mode, custom_mode, system_status, mavlink_version)

    def heartbeat_send(self, type, autopilot, base_mode, custom_mode, system_status, mavlink_version=3, force_mavlink1=False):
        """
        The heartbeat message shows that a system or component is present and
        responding. The type and autopilot fields (along with the
        message component id), allow the receiving system to treat
        further messages from this system appropriately (e.g. by
        laying out the user interface based on the autopilot). This
        microservice is documented at
        https://mavlink.io/en/services/heartbeat.html

        type                      : Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type. (type:uint8_t, values:MAV_TYPE)
        autopilot                 : Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers. (type:uint8_t, values:MAV_AUTOPILOT)
        base_mode                 : System mode bitmap. (type:uint8_t, values:MAV_MODE_FLAG)
        custom_mode               : A bitfield for use for autopilot-specific flags (type:uint32_t)
        system_status             : System status flag. (type:uint8_t, values:MAV_STATE)
        mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (type:uint8_t)

        """
        return self.send(self.heartbeat_encode(type, autopilot, base_mode, custom_mode, system_status, mavlink_version), force_mavlink1=force_mavlink1)

    def protocol_version_encode(self, version, min_version, max_version, spec_version_hash, library_version_hash):
        """
        Version and capability of protocol version. This message can be
        requested with MAV_CMD_REQUEST_MESSAGE and is used as part of
        the handshaking to establish which MAVLink version should be
        used on the network. Every node should respond to a request
        for PROTOCOL_VERSION to enable the handshaking. Library
        implementers should consider adding this into the default
        decoding state machine to allow the protocol core to respond
        directly.

        version                   : Currently active MAVLink version number * 100: v1.0 is 100, v2.0 is 200, etc. (type:uint16_t)
        min_version               : Minimum MAVLink version supported (type:uint16_t)
        max_version               : Maximum MAVLink version supported (set to the same value as version by default) (type:uint16_t)
        spec_version_hash         : The first 8 bytes (not characters printed in hex!) of the git hash. (type:uint8_t)
        library_version_hash        : The first 8 bytes (not characters printed in hex!) of the git hash. (type:uint8_t)

        """
        return MAVLink_protocol_version_message(version, min_version, max_version, spec_version_hash, library_version_hash)

    def protocol_version_send(self, version, min_version, max_version, spec_version_hash, library_version_hash, force_mavlink1=False):
        """
        Version and capability of protocol version. This message can be
        requested with MAV_CMD_REQUEST_MESSAGE and is used as part of
        the handshaking to establish which MAVLink version should be
        used on the network. Every node should respond to a request
        for PROTOCOL_VERSION to enable the handshaking. Library
        implementers should consider adding this into the default
        decoding state machine to allow the protocol core to respond
        directly.

        version                   : Currently active MAVLink version number * 100: v1.0 is 100, v2.0 is 200, etc. (type:uint16_t)
        min_version               : Minimum MAVLink version supported (type:uint16_t)
        max_version               : Maximum MAVLink version supported (set to the same value as version by default) (type:uint16_t)
        spec_version_hash         : The first 8 bytes (not characters printed in hex!) of the git hash. (type:uint8_t)
        library_version_hash        : The first 8 bytes (not characters printed in hex!) of the git hash. (type:uint8_t)

        """
        return self.send(self.protocol_version_encode(version, min_version, max_version, spec_version_hash, library_version_hash), force_mavlink1=force_mavlink1)
